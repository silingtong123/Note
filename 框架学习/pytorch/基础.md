### 编译安装
- 

### 常用命名空间
- at 代表 ATen (A Tensor Library)，负责声明和定义Tensor运算相关的逻辑，是pytorch扩展c++接口中最常用到的命名空间
- c10 (Caffe Tensor Library)其实是 ATen 的基础，包含了PyTorch的核心抽象、Tensor和Storage数据结构的实际实现
- torch 命名空间下定义的 Tensor 相比于ATen 增加自动求导功能，但 c++ 扩展中一般不常见

### pybind11
- python -> C++转换： 从Python到C，要用到PyArg_ParseTuple()函数，从C到Python要用到Py_BuildValue()函数
  - 包含python头文件。#include "Python.h" 
  - 为每一个模块函数添加形如PyObject* Module_func()的封装函数
  - 为每一个模块函数添加一个PyMethodDef ModuleMethods[]数组/表
  - 添加模块初始化函数void initModule()
- PyArg_ParseTuple(args,format,...)
  - "b" (integer) [char] python整数->char中的tiny int
  - "h" (integer) [short int]  python整数->C语言short int。
  - "i" (integer) [int] python整数->C语言int
  - "l" (integer) [long int] python整数->long int
  - "f" (float) [float] python float->float
  - "d" (float) [double] python float->double
  - "D" (complex) [Py_complex] python 复数转换为C语言Py_complex结构
  - "O" (object) [PyObject *] 在C对象指针中存储Python对象(不进行任何转换)
  - "O!" (object)[typeobject, PyObject *] 这类似于“O”，但是接受两个C参数:第一个是Python类型对象的地址，第二个是对象指针存储在其中的C变量(类型为PyObject *)的地址
  - "O&" (object)[converter,anything] 通过转换器函数将Python对象转换为C变量。这需要两个参数:第一个是函数，第二个是C变量(任意类型)的地址
  - "S" (string) [PyStringObject *]：在C对象指针中存储Python string
  - "U" (Unicode string) [PyUnicodeObject *]：在C对象指针中存储Python Unicode对象
  - "s" (string or Unicode object) [char *]：将 python string or Unicode object -》 c char *
  - "s#" (string,Unicode or any read buffer compatible object) [char *, int]：“s”上的这个变体存储在两个C变量中，第一个变量是指向字符串的指针，第二个变量是字符串的长度
  - "z" (string or None) [char *]：与“s”类似，但是Python对象也可能是None，在这种情况下，C指针被设置为NULL
  - "z#" (string or None or any read buffer compatible object) [char *, int]：类似s和s#的关系
  - "u" (Unicode object) [Py_UNICODE *]将Python Unicode对象转换为指向16位Unicode (UTF-16)数据的空端缓冲区的C指针
  - "t#" (read-only character buffer) [char *, int]：与“s#”类似，但接受任何实现只读缓冲区接口的对象。char *变量设置为指向缓冲区的第一个字节，int设置为缓冲区的长度
  - "w" (read-write character buffer) [char *]：类似于“s”，但接受任何实现读写缓冲区接口的对象。调用者必须通过其他方法确定缓冲区的长度，或者使用“w#”
  - "w#" (read-write character buffer) [char *, int]：与“s#”类似，但接受任何实现读写缓冲区接口的对象。char *变量设置为指向缓冲区的第一个字节，int设置为缓冲区的长度
  - "|" 指示Python参数列表中的其余参数是可选的
  - ":"格式单元列表在此结束;冒号后面的字符串用作错误消息中的函数名
  - ";" 格式单元列表在此结束;冒号后面的字符串用作错误消息，而不是默认错误消息
-  pybind.cpp
-  ```C++
   class CppFunction{
     c10::optional<c10::DispatchKey> dispatch_key_;
     c10::KernelFunction func_; // 类似std::function
     c10::optional<c10::impl::CppSignature> cpp_signature_;
     std::unique_ptr<c10::FunctionSchema> schema_;
     std::string debug_;   
   }

   class BoxedKernel { //类似std::function
      c10::intrusive_ptr<OperatorKernel> functor_;
      InternalBoxedKernelFunction* boxed_kernel_func_;   
   } 

   TORCH_LIBRARY_IMPL(myops, CPU, m) // m is a torch::Library, myops is namespace
   ```
- PYBIND11_MODULE(module_name, m):第一个参数为module_name,第二个为是py::module类型

### TorchScript
- intrusive_ptr视为类似于std::shared_ptr的智能指针,使用此智能指针的原因是为了确保在语言(C ++，Python 和 TorchScript）之间对对象实例进行一致的生命周期管理

### C++ inference
- CMakeLists.txt:
```
cmake_minimum_required(VERSION 3.0 FATAL_ERROR)
project(custom_ops)

find_package(Torch REQUIRED)

add_executable(example-app example-app.cpp)
target_link_libraries(example-app "${TORCH_LIBRARIES}")
set_property(TARGET example-app PROPERTY CXX_STANDARD 14)
```
- 编译命令:使用libtorch或者libtorch_cuda
```
mkdir build
cd build
cmake -DCMAKE_PREFIX_PATH=/path/to/libtorch .. / 
cmake --build . --config Release
```

### 加载保存模型
- 第一种（推荐）：
  - torch.save(model.state_dict(), 'model_path.pth')
  - model.load_state_dict(torch.load('model_path.pth'))
- 第二种：
  - torch.save(model, 'model.pth')
  - model = torch.load('model.pth')


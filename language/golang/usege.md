### 注意

#### 语言特性
- <font color="#00dd00"> 对于有 C/C++ 编程经验的程序员需要强调的是：不用关心 Go 语言中函数栈和堆的问题，编译器和运行时会帮我们搞定；同样不要假设变量在内存中的位置是固定不变的，指针随时可能会变化，特别是在你不期望它变化的时候</font><br />
- Go 语言中，对于基础类型（非接口类型）不支持隐式的转换,但是 Go 语言对于接口类型的转换则非常的灵活。对象和接口之间的转换、接口和接口之间的转换都可能是隐式的转换
- Go为编译性语言，直接将源代码 编译为二进制文件
  - 编译型语言：C.C++，java
  - 解释型语言：python， ruby,js	
- Go 语言中，通过在结构体内置匿名的成员来实现继承
- golang默认的是值传递，即深拷贝
- defer类似C++的RAII

#### 线程和携程
- 每个系统级线程都会有一个固定大小的栈（一般默认可能是 2MB），这个栈主要用来保存函数递归调用时参数和局部变量。固定了栈的大小导致了两个问题：一是对于很多只需要很小的栈空间的线程来说是一个巨大的浪费，二是对于少数需要巨大栈空间的线程来说又面临栈溢出的风险。针对这两个问题的解决方案是：要么降低固定的栈大小，提升空间的利用率；要么增大栈的大小以允许更深的函数递归调用，但这两者是没法同时兼得的
- 一个 Goroutine 会以一个很小的栈启动（可能是 2KB 或 4KB），当遇到深度递归导致当前栈空间不足时，Goroutine 会根据需要动态地伸缩栈的大小（主流实现中栈的最大值可达到1GB）。因为启动的代价很小，所以我们可以轻易地启动成千上万个 Goroutine
- Go的运行时还包含了其自己的调度器，这个调度器使用了一些技术手段，可以在 n 个操作系统线程上多工调度 m 个 Goroutine   


#### 项目初始化
- go env -w GO111MODULE=on
- go mod init xxx 
- 简单执行命令： go run *.go
- 简单编译命令：go build * -o main
- 单元测试：
  - 格式要求：文件必须*_test.go， 测试用例函数必须func TestXXX( t *testing.T )
  - 启动命令：go test helloworld_test.go / go test -v helloworld_test.go /查看详细信息
  - 只运行单个测试用例函数： go test -v -run TestA select_test.go
- 安装gin package: go get -u github.com/gin-gonic/gin

